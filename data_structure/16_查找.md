# 查找

## 常用查找

1. 顺序（线性）查找
2. 二分查找/折半查找
3. 插值查找
4. 斐波那契查按

## 线性查找

```java
// 简单的线性查找，找到一个val就返回下标
public static int seqSearch(int[] arr, int val) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == val) {
            return i;
        }
    }
    return -1;
}
```

## 二分查找

前提：待查找数组有序

### 思路分析

1. 首先确定该数组的中间的下标 `mid = (left+right) / 2`
2. 然后让需要查找的数`findval`和`arr[mid]`比较
2.1 `findVal > arr[mid]`，说明你要查找的数在`mid`的右边，因此需要递归的向右查找。
2.2 `findval < arr[mid]`，说明你要查找的数在`mid`的左边，因此需要递归的向左查找。
2.3 `findval == arr[mid]`说明找到，就返回
什么时候我们需要结束递归？
   - 找到就结束递归
   - 递归完整个数组，仍然没有找到`findval`，也需要结束递归，当`left > right`就需要退出

### 代码实现

```java
// 二分查找，只返回第一个元素下标
public static int BinarySearch(int[] arr, int findVal, int left, int right) {
    // 未找到
    if (left > right) {
        return -1;
    }
    int mid = (left + right) / 2;
    if (findVal < arr[mid]) {
        return BinarySearch(arr, findVal, left, mid - 1);
    } else if (findVal > arr[mid]) {
        return BinarySearch(arr, findVal, mid + 1, right);
    } else {
        return mid;
    }
}
// 二分查找，返回所有元素的下标集合，这里用ArrayList存储，也可以用数组存储
public static List<Integer> BinaryMultiSearch(int[] arr, int findVal, int left, int right) {
    // 未找到
    if (left > right) {
        return null;
    }
    int mid = (left + right) / 2;
    if (findVal < arr[mid]) {
        return BinaryMultiSearch(arr, findVal, left, mid - 1);
    } else if (findVal > arr[mid]) {
        return BinaryMultiSearch(arr, findVal, mid + 1, right);
    } else {
        List<Integer> res = new ArrayList<>();
        res.add(mid);
        int temp = mid - 1;
        while (temp >= left && arr[temp] == findVal) {
            res.add(temp);
            temp--;
        }
        temp = mid + 1;
        while (temp <= right && arr[temp] == findVal) {
            res.add(temp);
            temp++;
        }
        return res;
    }
}
```


