# 内容共享

- [内容共享](#内容共享)
  - [在应用之间共享数据](#在应用之间共享数据)
    - [通过ContentProvider封装数据](#通过contentprovider封装数据)
    - [通过ContentResolver访问数据](#通过contentresolver访问数据)
  - [使用内容组件获取通讯信息](#使用内容组件获取通讯信息)
    - [运行时动态申请权限](#运行时动态申请权限)
    - [利用ContentResolver读写联系人](#利用contentresolver读写联系人)
    - [利用ContentObserver监听短信](#利用contentobserver监听短信)
  - [在应用之间共享文件](#在应用之间共享文件)
    - [使用相册图片发送彩信](#使用相册图片发送彩信)
    - [借助FileProvider发送彩信](#借助fileprovider发送彩信)
    - [借助FileProvider安装应用](#借助fileprovider安装应用)

## 在应用之间共享数据

ContentProvider为App存取内部数据提供统一的外部接口，让不同的应用之间得以共享数据。

![content_provider](./img/content_provider.png)

Client App 将用户的输入内容，通过ContentProvider跨进程通信传递给Server Appo

![case_of_content_provider](./img/case_of_content_provider.png)

### 通过ContentProvider封装数据

ContentProvider只是服务端App存取数据的抽象类，我们需要在其基础上实现一个完整的内容提供器，并重写下列方法。

- onCreate：创建数据库并获得数据库连接。
- insert：插入数据。
- delete：删除数据。
- update：更新数据。
- query：查询数据，并返回结果集的游标。
- getType：获取内容提供器支持的数据类型。

Uri（通用资源标识符Universal Resource ldentifer），代表数据操作的地址，每一个ContentProvider都会有唯一的地址。ContentProvider使用的Uri语法结构如下：

`content://authority/data_path/id`
- `content://`是通用前缀，表示该Uri用于ContentProvider定位资源。
- `authority`是授权者名称，用来确定具体由哪一个ContentProvider提供资源。因此一般authority都由类的小写全称组成，以保证唯一性。
- `data_path`是数据路径，用来确定请求的是哪个数据集。
- `id` 是数据编号，用来请求单条数据。如果是多条这个字段忽略。


### 通过ContentResolver访问数据

利用ContentProvider只实现服务端App的数据封装，如果客户端App想访问对方的内部数据,就要通过内容解析器ContentResolver访问。

![content_resolver](./img/content_resolver.png)


## 使用内容组件获取通讯信息

### 运行时动态申请权限

Android系统为了防止某些App滥用权限，从6.0开始引入了运行时权限管理机制，允许App在运行过程中动态检查是否拥有某项权限，一旦发现缺少某种必需的权限，则系统会自动弹出小窗提示用户去开启该权限。

**动态申请权限的步骤**

（1）检查App是否开启了指定权限

- 调用ContextCompat的checkSelfPermission方法。

（2）请求系统弹窗，以便用户选择是否开启权限

- 调用ActivityCompat的requestPermissions方法，即可命令系统自动弹出权限申请窗口。

（3）判断用户的权限选择结果

- 重写活动页面的权限请求回调方法onRequestPermissionsResult，在该方法内部处理用户的权限选择结果。


### 利用ContentResolver读写联系人

写入联系人有两种：

**方式一：直接写入**
```java
private void addContacts(ContentResolver resolver, Contact contact) {
    ContentValues values = new ContentValues();
    Uri uri = resolver.insert(RawContacts.CONTENT_URI, values);
    long rawContactId = ContentUris.parseId(uri);
    ContentValues name = new ContentValues();
    name.put(Contacts.Data.RAW_CONTACT_ID, rawContactId);
    name.put(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE);
    name.put(Contacts.Data.DATA2, contact.name);
    resolver.insert(Data.CONTENT_URI, name);

    ContentValues phone = new ContentValues();
    phone.put(Contacts.Data.RAW_CONTACT_ID, rawContactId);
    phone.put(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE);
    phone.put(Contacts.Data.DATA1, contact.phone);
    phone.put(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE);// 类型
    resolver.insert(Data.CONTENT_URI, phone);

    ContentValues email = new ContentValues();
    email.put(Contacts.Data.RAW_CONTACT_ID, rawContactId);
    email.put(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE);
    email.put(Contacts.Data.DATA1, contact.email);
    email.put(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_WORK);// 类型：工作
    resolver.insert(Data.CONTENT_URI, email);
}
```
**方式二：批处理方式**

每一次操作都是一个 ContentProviderOperation，构建一个操作集合，然后一次性执行

好处是，要么全部成功，要么全部失败，保证了事务的一致性

```java
private void addFullContact(ContentResolver resolver, Contact contact) {
    ContentProviderOperation op_main = ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)
            .withValue(RawContacts.ACCOUNT_NAME, null)
            .build();
    ContentProviderOperation op_name = ContentProviderOperation.newInsert(Data.CONTENT_URI)
            //将第O个操作的id，即 raw contacts 的 id 作为 data表中的 raw_contact_id
            .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0)
            .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
            .withValue(Contacts.Data.DATA2, contact.name)
            .build();

    ContentProviderOperation op_phone = ContentProviderOperation.newInsert(Data.CONTENT_URI)
            //将第O个操作的id，即 raw contacts 的 id 作为 data表中的 raw_contact_id
            .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0)
            .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
            .withValue(Contacts.Data.DATA1, contact.phone)
            .withValue(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE)
            .build();

    ContentProviderOperation op_email = ContentProviderOperation.newInsert(Data.CONTENT_URI)
            //将第O个操作的id，即 raw contacts 的 id 作为 data表中的 raw_contact_id
            .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0)
            .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE)
            .withValue(Contacts.Data.DATA1, contact.email)
            .withValue(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_WORK)
            .build();

    ArrayList<ContentProviderOperation> operations = new ArrayList<>();
    operations.add(op_main);
    operations.add(op_name);
    operations.add(op_phone);
    operations.add(op_email);

    try {
        resolver.applyBatch(AUTHORITY, operations);
    } catch (OperationApplicationException e) {
        e.printStackTrace();
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
```

### 利用ContentObserver监听短信

## 在应用之间共享文件

### 使用相册图片发送彩信

### 借助FileProvider发送彩信

### 借助FileProvider安装应用